# Task #12 - delegation Block - Structure Skeleton

## Summary
Created structure skeleton for `delegation` block. This is a list block that allows configuring subnet delegations to Azure services. The block contains comment placeholders for child fields (`name`, `serviceName`, `actions`) to be implemented by subsequent tasks (#13, #15, #16).

## Shadow Implementation
```hcl
locals {
  body = {
    properties = merge(
      # ... other fields ...
      var.delegation != null ? {                                              # <-
        delegations = [                                                       # <-
          for delegation_item in var.delegation : {                           # <-
            # name = ... # Task #13                                           # <-
            properties = {                                                    # <-
              # serviceName = ... # Task #15                                 # <-
              # actions = ... # Task #16                                     # <-
            }                                                                 # <-
          }                                                                   # <-
        ]                                                                     # <-
      } : {}                                                                  # <-
    )
  }
}
```

## Create Phase Verification

### Querying Create Method
Queried `resourceSubnetCreate` to identify where delegation is processed.

### Provider Create Method Evidence
```go
func resourceSubnetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	properties := subnets.SubnetPropertiesFormat{}
	// ... other fields ...
	
	delegationsRaw := d.Get("delegation").([]interface{})
	properties.Delegations = expandSubnetDelegation(delegationsRaw)

	subnet := subnets.Subnet{
		Name:       pointer.To(id.SubnetName),
		Properties: &properties,
	}

	if err := client.CreateOrUpdateThenPoll(ctx, id, subnet); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}
	// ...
}
```

### Classification
- **Pattern**: Single-phase (only primary `CreateOrUpdateThenPoll`)
- **Field Classification**: Create phase - processed before primary create operation
- **Assignment**: Assigned to `properties.Delegations` in the Create method

### Decision
The `delegation` field is processed in the Create phase and assigned to `local.body.properties.delegations`.

## Assignment Path Verification

### Predicted Path
`body.properties.delegations`

### Provider Code Evidence

**Step 1 - Field Retrieval:**
```go
delegationsRaw := d.Get("delegation").([]interface{})
properties.Delegations = expandSubnetDelegation(delegationsRaw)
```

**Step 2 - Struct Assignment:**
```go
subnet := subnets.Subnet{
	Name:       pointer.To(id.SubnetName),
	Properties: &properties,  // <- SubnetPropertiesFormat assigned to Properties
}
```

**Step 3 - API Call:**
```go
if err := client.CreateOrUpdateThenPoll(ctx, id, subnet); err != nil {
	return fmt.Errorf("creating %s: %+v", id, err)
}
```

### Trace of Assignments
1. `delegationsRaw` retrieved from Terraform state
2. `expandSubnetDelegation(delegationsRaw)` expands to `*[]subnets.Delegation`
3. Assigned to `properties.Delegations` field
4. `properties` (type `SubnetPropertiesFormat`) assigned to `subnet.Properties`
5. `subnet` sent to Azure API via `CreateOrUpdateThenPoll`

### Verified Path
`body.properties.delegations` ✅

### Path Comparison
**Predicted**: `body.properties.delegations`
**Verified**: `body.properties.delegations`
**Match**: ✅ YES

## Provider Schema

### Terraform Schema
```go
"delegation": {
	Type:     pluginsdk.TypeList,
	Optional: true,
	Elem: &pluginsdk.Resource{
		Schema: map[string]*pluginsdk.Schema{
			"name": {
				Type:     pluginsdk.TypeString,
				Required: true,
			},
			"service_delegation": {
				Type:     pluginsdk.TypeList,
				Required: true,
				MaxItems: 1,
				Elem: &pluginsdk.Resource{
					Schema: map[string]*pluginsdk.Schema{
						"name": {
							Type:         pluginsdk.TypeString,
							Required:     true,
							ValidateFunc: validation.StringInSlice(subnetDelegationServiceNames, false),
						},

						"actions": {
							Type:     pluginsdk.TypeSet,
							Optional: true,
							Elem: &pluginsdk.Schema{
								Type: pluginsdk.TypeString,
								ValidateFunc: validation.StringInSlice([]string{
									"Microsoft.Network/networkinterfaces/*",
									"Microsoft.Network/publicIPAddresses/join/action",
									"Microsoft.Network/publicIPAddresses/read",
									"Microsoft.Network/virtualNetworks/read",
									"Microsoft.Network/virtualNetworks/subnets/action",
									"Microsoft.Network/virtualNetworks/subnets/join/action",
									"Microsoft.Network/virtualNetworks/subnets/prepareNetworkPolicies/action",
									"Microsoft.Network/virtualNetworks/subnets/unprepareNetworkPolicies/action",
								}, false),
							},
						},
					},
				},
			},
		},
	},
},
```

**Key Schema Details:**
- `delegation`: `TypeList`, `Optional`
- `delegation.name`: `TypeString`, `Required` (no ForceNew)
- `delegation.service_delegation`: `TypeList`, `Required`, `MaxItems: 1`
- `delegation.service_delegation.name`: `TypeString`, `Required`, validated against service names
- `delegation.service_delegation.actions`: `TypeSet`, `Optional`, validated against action strings

## Expand Function Analysis

### expandSubnetDelegation Function
```go
func expandSubnetDelegation(input []interface{}) *[]subnets.Delegation {
	retDelegations := make([]subnets.Delegation, 0)

	for _, deleValue := range input {
		deleData := deleValue.(map[string]interface{})
		deleName := deleData["name"].(string)
		srvDelegations := deleData["service_delegation"].([]interface{})
		srvDelegation := srvDelegations[0].(map[string]interface{})
		srvName := srvDelegation["name"].(string)
		srvActions := srvDelegation["actions"].(*pluginsdk.Set).List()

		retSrvActions := make([]string, 0)
		for _, srvAction := range srvActions {
			srvActionData := srvAction.(string)
			retSrvActions = append(retSrvActions, srvActionData)
		}

		retDelegation := subnets.Delegation{
			Name: &deleName,
			Properties: &subnets.ServiceDelegationPropertiesFormat{
				ServiceName: &srvName,
				Actions:     &retSrvActions,
			},
		}

		retDelegations = append(retDelegations, retDelegation)
	}

	return &retDelegations
}
```

**Logic:**
1. Iterates through each delegation item in the list
2. Extracts `name` from each delegation
3. Extracts `service_delegation` (takes first element since MaxItems: 1)
4. Extracts `name` and `actions` from service_delegation
5. Constructs `Delegation` object with:
   - `Name`: delegation name
   - `Properties.ServiceName`: service delegation name
   - `Properties.Actions`: array of action strings

**No hidden fields added in expand function** - only transforms the nested structure.

## Azure API Schema

### Azure SDK Types

**Delegation Type:**
```go
type Delegation struct {
	Etag       *string                            `json:"etag,omitempty"`
	Id         *string                            `json:"id,omitempty"`
	Name       *string                            `json:"name,omitempty"`
	Properties *ServiceDelegationPropertiesFormat `json:"properties,omitempty"`
	Type       *string                            `json:"type,omitempty"`
}
```

**ServiceDelegationPropertiesFormat Type:**
```go
type ServiceDelegationPropertiesFormat struct {
	Actions           *[]string          `json:"actions,omitempty"`
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty"`
	ServiceName       *string            `json:"serviceName,omitempty"`
}
```

### Property Path
`body.properties.delegations` (array)

Each delegation object contains:
- `name`: Delegation name
- `properties.serviceName`: Service to delegate to
- `properties.actions`: List of delegated actions

## Hidden Fields

### Identified Hidden Fields in Azure API

**Root delegation object (read-only/managed by Azure):**
1. `id` - Resource ID of the delegation (omitempty, computed)
2. `etag` - Unique read-only string (omitempty, computed)
3. `type` - Resource type (omitempty, computed)

**In properties (read-only/managed by Azure):**
4. `provisioningState` - Provisioning state of the delegation (omitempty, computed)

**Provider Behavior:**
The `expandSubnetDelegation` function ONLY sets:
- `Name` (from `delegation.name`)
- `Properties.ServiceName` (from `service_delegation.name`)
- `Properties.Actions` (from `service_delegation.actions`)

All other fields (`id`, `etag`, `type`, `provisioningState`) are computed/managed by Azure and NOT set by the provider.

**Conclusion:** No hidden fields need to be added to the skeleton - the provider does not set any additional fields beyond what's exposed in the Terraform schema.

## Mapping

| Terraform Field | Azure API Field | Notes |
|----------------|-----------------|-------|
| `delegation` (list) | `body.properties.delegations` (array) | List of delegation objects |
| `delegation[*].name` | `delegations[*].name` | Delegation name |
| `delegation[*].service_delegation.name` | `delegations[*].properties.serviceName` | Service name (camelCase) |
| `delegation[*].service_delegation.actions` | `delegations[*].properties.actions` | Action list |
| N/A | `delegations[*].id` | Hidden - computed by Azure |
| N/A | `delegations[*].etag` | Hidden - computed by Azure |
| N/A | `delegations[*].type` | Hidden - computed by Azure |
| N/A | `delegations[*].properties.provisioningState` | Hidden - computed by Azure |

## Special Handling

### Block Structure
- **Type**: List block (allows multiple delegation entries)
- **Nesting**: Contains nested `service_delegation` block with `MaxItems: 1`
- **Transformation**: Flattens nested structure to Azure API format

### ForceNew Analysis
**Schema Check**: No `ForceNew: true` on any delegation fields
**CustomizeDiff Check**: No CustomizeDiff logic for delegation fields
**Conclusion**: Delegation fields do NOT trigger resource replacement

### Validations
All validations will be handled by child tasks:
- Task #13: `delegation.name` (Required)
- Task #15: `service_delegation.name` (Required, validated against service names - already in variables.tf)
- Task #16: `service_delegation.actions` (Optional, validated against action list - already in variables.tf)

### Conditional Logic
The skeleton uses `var.delegation != null` to conditionally include the delegations array only when the user provides delegation configuration.

## Child Tasks Ready for Delegation

Based on track.md, the following child tasks are now ready to be worked on:
- **Task #13**: `delegation.name` - Implement delegation name field
- **Task #14**: `delegation.service_delegation` - This is the nested block container (structure already created, no separate implementation needed)
- **Task #15**: `delegation.service_delegation.name` - Implement service delegation name field
- **Task #16**: `delegation.service_delegation.actions` - Implement service delegation actions field

**All child tasks (#13, #15, #16) can now proceed** since the parent block structure skeleton is complete.

## Edge Case Analysis

### Null Handling
- **`var.delegation == null`**: Entire `delegations` key omitted from API payload (conditional via ternary)
- **Empty list `[]`**: Would result in empty array `delegations: []` sent to API

### Empty Collections
- **Empty delegation list**: Provider would send `delegations: []` to API - valid Azure API input
- **No actions specified**: Provider sets `Actions: &[]string{}` (empty slice pointer) - valid

### Idempotency
- **List iteration**: Uses `for` expression which maintains order
- **Deterministic output**: Same input always produces same output structure
- **Note**: Azure may return delegations in different order, but this is an Azure API behavior

### Safe References
- **Null check**: `var.delegation != null` prevents attempting to iterate over null
- **Nested access**: All nested fields accessed through direct variable references (safe)
- **Array indexing**: Expand function uses `[0]` on `service_delegation` which is safe because schema enforces `MaxItems: 1`

## Checklist

- ✅ Skeleton structure created with conditional check
- ✅ Comment placeholders added for child fields with task numbers
- ✅ Create phase verified (single-phase, Create phase)
- ✅ Assignment path verified (body.properties.delegations)
- ✅ Hidden fields checked (none to add - all computed by Azure)
- ✅ Expand function analyzed (no hidden logic)
- ✅ Edge cases analyzed (null, empty, idempotency, safe refs)
- ✅ Child tasks identified (#13, #15, #16 are ready)
- ✅ ForceNew analysis (no ForceNew behavior)
- ✅ Validations deferred to child tasks
- ✅ Self-review: Only skeleton added, no implementation of child fields
- ✅ track.md will be updated to "Pending for check"

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2026-01-20
**Task:** #12 - delegation

### Issues Identified

#### Issue 1: Type 3 Task Violation - Implementation Instead of Placeholder

**Problem:**
The executor implemented the `name` field (`name = delegation_item.name # Task #13`) instead of creating a comment placeholder as required for Type 3 (Block Structure Skeleton) tasks.

**Executor's Implementation:**
```hcl
for delegation_item in var.delegation : {
  name = delegation_item.name # Task #13
  properties = {
    # serviceName = ... # Task #15
    # actions = ... # Task #16
  }
}
```

**Why This Violates executor.md:**
From executor.md Type 3 instructions (lines 453-463):
> **Create skeleton ONLY:**
> ```hcl
> locals {
>   body = {
>     properties = merge(
>       var.os_disk != null ? {
>         virtualMachineProfile = { storageProfile = { osDisk = { # caching = ... # Task #88
>         } } }
>       } : {}
>     )
>   }
> }
> ```

Type 3 tasks must create structural skeleton with **comment placeholders** for ALL child fields. The example shows `# caching = ... # Task #88` as a comment, not an implementation.

**Expected Behavior:**
- Type 3 task creates structural skeleton only
- ALL child fields (including `name`) must be comment placeholders
- Child fields are implemented by their respective Type 4 tasks (Task #13 for name)

**Root Cause:**
Executor misunderstood Type 3 scope and partially implemented a child field, blurring the boundary between skeleton creation (Type 3) and field implementation (Type 4).

### Corrections Made

#### Fix 1: Convert name Field to Comment Placeholder

**Changed Files:**
- `migrate_main.tf`: Converted `name = delegation_item.name # Task #13` to comment placeholder
- `12.delegation.md`: Updated Shadow Implementation section to reflect correct skeleton-only approach

**New Implementation:**
```hcl
var.delegation != null ? {
  delegations = [
    for delegation_item in var.delegation : {
      # name = ... # Task #13
      properties = {
        # serviceName = ... # Task #15
        # actions = ... # Task #16
      }
    }
  ]
} : {}
```

**Why This is EXACT:**
This matches the Type 3 task definition exactly:
1. Creates structural skeleton with conditional check
2. Sets up iteration with `for delegation_item in var.delegation`
3. Creates nested object structure (delegation → properties)
4. Places **comment placeholders** for ALL child fields
5. Defers actual field implementation to Type 4 tasks

**Verification:**
- Scenario 1: Type 3 skeleton task → Creates structure with comment placeholders ✅
- Scenario 2: Type 4 child tasks (#13, #15, #16) → Will replace comments with actual implementations ✅
- Edge Case: Clear separation of concerns between skeleton and field implementation ✅

### Compliance Statement

After corrections, this implementation now EXACTLY replicates the Type 3 task requirements from `executor.md`. The skeleton provides the structural foundation without implementing any child fields, allowing Type 4 tasks to cleanly implement each field independently.

**Status:** CORRECTED AND APPROVED ✅

---
