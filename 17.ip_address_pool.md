# Task #17 - ip_address_pool Block - Structure Skeleton

## Summary

Created the structure skeleton for the `ip_address_pool` block, mapping to Azure API's `ipamPoolPrefixAllocations` array. The block contains two child fields (id and numberOfIpAddresses) that will be implemented in subsequent tasks (#18 and #19).

## Task Type

Type 3: Block Structure Skeleton - Create skeleton ONLY with comment placeholders for child arguments.

## Create Phase Verification

### Query Create Method

Queried the Create method (`resourceSubnetCreate`) to identify how `ip_address_pool` is processed.

### Go Code Evidence

```go
properties.IPamPoolPrefixAllocations = expandSubnetIPAddressPool(d.Get("ip_address_pool").([]interface{}))
```

### Pattern Classification

**Single-phase pattern**: The field is set directly on `properties` before the primary `CreateOrUpdateThenPoll` call.

### Decision

Field is assigned in the Create phase, before the primary create operation. Therefore, it goes in `local.body.properties`.

## Assignment Path Verification

### Predicted Path

`body.properties.ipamPoolPrefixAllocations`

### Go Code Evidence - Struct Assignment Trace

**Step 1 - Expand function:**
```go
func expandSubnetIPAddressPool(input []interface{}) *[]subnets.IPamPoolPrefixAllocation {
	if len(input) == 0 {
		return nil
	}

	outputs := make([]subnets.IPamPoolPrefixAllocation, 0)
	for _, v := range input {
		ipPoolRaw := v.(map[string]interface{})
		output := subnets.IPamPoolPrefixAllocation{}

		if v, ok := ipPoolRaw["number_of_ip_addresses"]; ok {
			output.NumberOfIPAddresses = pointer.To(v.(string))
		}

		if v, ok := ipPoolRaw["id"]; ok {
			output.Pool = &subnets.IPamPoolPrefixAllocationPool{
				Id: pointer.To(v.(string)),
			}
		}

		outputs = append(outputs, output)
	}

	return &outputs
}
```

**Step 2 - Assignment to properties:**
```go
properties := subnets.SubnetPropertiesFormat{}
// ... other fields ...
properties.IPamPoolPrefixAllocations = expandSubnetIPAddressPool(d.Get("ip_address_pool").([]interface{}))
```

**Step 3 - Properties assigned to subnet:**
```go
subnet := subnets.Subnet{
	Name:       pointer.To(id.SubnetName),
	Properties: &properties,  // <- Adds "properties" nesting
}
```

**Step 4 - Subnet sent to API:**
```go
if err := client.CreateOrUpdateThenPoll(ctx, id, subnet); err != nil {
	return fmt.Errorf("creating %s: %+v", id, err)
}
```

### Verified Path

`body.properties.ipamPoolPrefixAllocations`

### Path Comparison

✅ **MATCH** - Predicted path matches verified path exactly.

## Provider Schema

### Schema Definition

```go
"ip_address_pool": {
	Type:         pluginsdk.TypeList,
	Optional:     true,
	MaxItems:     1,
	ExactlyOneOf: []string{"address_prefixes", "ip_address_pool"},
	Elem: &pluginsdk.Resource{
		Schema: map[string]*pluginsdk.Schema{
			"id": {
				Type:         pluginsdk.TypeString,
				Required:     true,
				ValidateFunc: ipampools.ValidateIPamPoolID,
			},

			"number_of_ip_addresses": {
				Type:     pluginsdk.TypeString,
				Required: true,
				ValidateFunc: validation.StringMatch(
					regexp.MustCompile(`^[1-9]\d*$`),
					"`number_of_ip_addresses` must be a string that represents a positive number",
				),
			},

			"allocated_ip_address_prefixes": {
				Type:     pluginsdk.TypeList,
				Computed: true,
				Elem: &pluginsdk.Schema{
					Type: pluginsdk.TypeString,
				},
			},
		},
	},
},
```

### Schema Analysis

- **Type**: `TypeList` with `MaxItems: 1` (single block)
- **Optional**: Yes
- **ExactlyOneOf**: Mutually exclusive with `address_prefixes`
- **ForceNew**: Not present (no `ForceNew: true`)
- **Child Fields**:
  - `id`: Required, must be valid IPAM Pool ID
  - `number_of_ip_addresses`: Required, must be positive number as string
  - `allocated_ip_address_prefixes`: Computed only (not included in tasks)

## Azure API Schema

### SDK Type Structure

**IPamPoolPrefixAllocation:**
```go
type IPamPoolPrefixAllocation struct {
	AllocatedAddressPrefixes *[]string                     `json:"allocatedAddressPrefixes,omitempty"`
	NumberOfIPAddresses      *string                       `json:"numberOfIpAddresses,omitempty"`
	Pool                     *IPamPoolPrefixAllocationPool `json:"pool,omitempty"`
}
```

**IPamPoolPrefixAllocationPool:**
```go
type IPamPoolPrefixAllocationPool struct {
	Id *string `json:"id,omitempty"`
}
```

### API Property Path

`body.properties.ipamPoolPrefixAllocations` (array type)

## Hidden Fields Check

### Expand Function Analysis

Analyzed the `expandSubnetIPAddressPool` function to check for hidden fields.

### Hidden Fields Found

**NONE** - The expand function only processes the two fields defined in the schema:
1. `number_of_ip_addresses` → `NumberOfIPAddresses`
2. `id` → `Pool.Id`

The computed field `allocated_ip_address_prefixes` corresponds to `AllocatedAddressPrefixes` but is read-only and not set during Create/Update.

## Mapping

### Terraform → Azure API

| Terraform Field | Azure API Field | Notes |
|----------------|----------------|-------|
| `ip_address_pool` | `ipamPoolPrefixAllocations` | List with MaxItems:1 becomes array with single element |
| `ip_address_pool.id` | `ipamPoolPrefixAllocations[].pool.id` | Task #18 |
| `ip_address_pool.number_of_ip_addresses` | `ipamPoolPrefixAllocations[].numberOfIpAddresses` | Task #19 |
| *(computed)* `allocated_ip_address_prefixes` | `ipamPoolPrefixAllocations[].allocatedAddressPrefixes` | Read-only, not in locals |

### Naming Convention

- snake_case → camelCase
- `ip_address_pool` → `ipamPoolPrefixAllocations`
- Special case: array wrapper needed despite MaxItems:1

## Special Handling

### Array Structure

Even though the Terraform schema has `MaxItems: 1`, the Azure API expects an **array**. The skeleton creates a single-element array structure:

```hcl
ipamPoolPrefixAllocations = [
  {
    # Single element matching var.ip_address_pool
  }
]
```

### Mutual Exclusivity

The `ExactlyOneOf` constraint between `address_prefixes` and `ip_address_pool` is already validated in `variables.tf` (Task #4), so no additional validation needed here.

### Conditional Block

The entire block is conditional on `var.ip_address_pool != null`, consistent with the Optional schema definition.

## Implementation

### Code Changes

**File: `migrate_main.tf`**

Created skeleton structure with placeholders for child tasks:

```hcl
var.ip_address_pool != null ? {
  ipamPoolPrefixAllocations = [
    {
      # numberOfIpAddresses = ... # Task #19
      # pool = ... # Task #18 (nested structure with id field)
    }
  ]
} : {}
```

## Delegation to Child Tasks

### Ready for Delegation

The following child tasks are now **ready for execution**:

| Task # | Field | Type | Status |
|--------|-------|------|--------|
| **#18** | `ip_address_pool.id` | Argument | Ready |
| **#19** | `ip_address_pool.number_of_ip_addresses` | Argument | Ready |

Both child fields are Required arguments that can be implemented independently once the skeleton is verified.

## Edge Case Analysis

### Null Semantics

- `var.ip_address_pool == null` → Entire block omitted (empty merge contribution)
- `var.ip_address_pool != null` → Single-element array created with nested structure

### Boundary Conditions

- **Empty array**: Not possible - `MaxItems: 1` means if set, exactly 1 element
- **Multiple elements**: Prevented by schema `MaxItems: 1`
- **Missing required children**: Validated by child task implementations (#18, #19)

### Idempotency

Array structure is deterministic - same input always produces same output structure.

### Safe References

The conditional `var.ip_address_pool != null` protects against null access before attempting to reference child fields.

## Checklist

- ✅ Skeleton structure created in correct location (`body.properties`)
- ✅ Array wrapper added for API compatibility
- ✅ Comment placeholders added for each child field with task numbers
- ✅ Conditional block structure matches Optional schema
- ✅ Hidden fields checked in expand function (none found)
- ✅ No individual argument implementation (skeleton only)
- ✅ Proof document created with child task delegation
- ✅ Edge case analysis completed
- ✅ Self-review: Only skeleton for ip_address_pool added, no other fields
- ✅ track.md status ready to update to "Pending for check"

## Next Steps

After verification of this skeleton, proceed with:
1. Task #18: Implement `ip_address_pool.id` field
2. Task #19: Implement `ip_address_pool.number_of_ip_addresses` field

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-20
**Task:** #17 - ip_address_pool

### Validation Results

✅ **Task Type Compliance:** Type 3 (Block Structure Skeleton) - correctly implemented skeleton ONLY with comment placeholders for child fields
✅ **Phase Detection:** Correctly identified as Create phase based on Go code evidence showing `properties.IPamPoolPrefixAllocations` assignment before primary `CreateOrUpdateThenPoll`
✅ **Assignment Path Verification:** Complete trace from expand function through struct assignments verified correct path: `body.properties.ipamPoolPrefixAllocations`
✅ **Array Structure:** Correctly wraps single block in array to match Azure API expectations despite `MaxItems: 1` in Terraform schema
✅ **Conditional Logic:** Properly uses `var.ip_address_pool != null` guard for entire block
✅ **Placeholder Comments:** Both child fields (#18, #19) have comment placeholders with correct task numbers
✅ **Hidden Fields Check:** Confirmed no hidden fields in `expandSubnetIPAddressPool` function - only processes schema-defined fields
✅ **No Premature Implementation:** Skeleton only - no individual field values implemented (correct for Type 3)
✅ **Deferred Work Completion:** No deferred work for this task in following.md
✅ **Deferred Work Recording:** No deferrals made by this task (appropriate for structure skeleton)
✅ **Edge Case Analysis:** Complete analysis of null semantics, boundary conditions, idempotency, and safe references
✅ **Mutual Exclusivity:** Correctly noted that ExactlyOneOf validation with address_prefixes already handled in Task #4
✅ **Self-Review:** Executor confirmed only skeleton for ip_address_pool added, no other fields

### Compliance Statement

This implementation EXACTLY follows executor.md requirements for Type 3 (Block Structure Skeleton) tasks:
- Creates skeleton structure ONLY with comment placeholders
- Correctly identifies and documents the array wrapper requirement
- Provides complete path verification with struct assignment traces
- Delegates child field implementation to subsequent tasks (#18, #19)
- No premature implementation of individual arguments
- All proof document sections complete and accurate

**Status:** APPROVED ✅

---
