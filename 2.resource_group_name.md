# Task #2 - resource_group_name - COMPLETED

## Summary
Implemented the `resource_group_name` argument by creating a new `virtual_network_id` variable that represents the parent Virtual Network resource ID. The parent_id in azapi_header uses this variable instead of processing resource_group_name separately.

## Shadow Implementation
```hcl
# migrate_variables.tf
variable "virtual_network_id" { # <-
  type        = string # <-
  description = "(Required) The resource ID of the virtual network. Constructed from resource_group_name and virtual_network_name. Changing this forces a new resource to be created." # <-
  nullable    = false # <-
} # <-

# migrate_main.tf
locals {
  azapi_header = {
    type                 = "Microsoft.Network/virtualNetworks/subnets@2025-01-01"
    name                 = var.name
    location             = null
    parent_id            = var.virtual_network_id # <-
    tags                 = null
    ignore_null_property = true
    retry                = null
  }

  replace_triggers_external_values = {
    name               = { value = var.name }
    virtual_network_id = { value = var.virtual_network_id } # <-
  }
}
```

## Create Phase Verification

**Query:** `query_terraform_block_implementation_source_code(block_type="resource", terraform_type="azurerm_subnet", entrypoint_name="create")`

**Pattern:** Single-phase - One `CreateOrUpdateThenPoll` operation

**Go Code Evidence:**
```go
func resourceSubnetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    client := meta.(*clients.Client).Network.Subnets
    vnetClient := meta.(*clients.Client).Network.VirtualNetworks
    subscriptionId := meta.(*clients.Client).Account.SubscriptionId
    ctx, cancel := timeouts.ForCreate(meta.(*clients.Client).StopContext, d)
    defer cancel()

    log.Printf("[INFO] preparing arguments for Azure ARM Subnet creation.")

    id := commonids.NewSubnetID(subscriptionId, d.Get("resource_group_name").(string), d.Get("virtual_network_name").(string), d.Get("name").(string))
    // ...
    subnet := subnets.Subnet{
        Name:       pointer.To(id.SubnetName),
        Properties: &properties,
    }

    if err := client.CreateOrUpdateThenPoll(ctx, id, subnet); err != nil {
        return fmt.Errorf("creating %s: %+v", id, err)
    }
    // ...
}
```

**Decision:** The `resource_group_name` field is used to construct the subnet ID during primary Create phase. It's part of the resource ID hierarchy: `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}`. Since subnets are child resources of Virtual Networks, the parent_id should be the Virtual Network ID, which includes the resource group name in its path.

## Assignment Path Verification

**Predicted Path:** Not in request body - used only for resource ID construction

**Go Code Evidence:**
```go
// resource_group_name is used in ID construction, not in the subnet object
id := commonids.NewSubnetID(subscriptionId, d.Get("resource_group_name").(string), d.Get("virtual_network_name").(string), d.Get("name").(string))

// The subnet object sent to Azure API doesn't include resource_group_name
subnet := subnets.Subnet{
    Name:       pointer.To(id.SubnetName),
    Properties: &properties,
}

if err := client.CreateOrUpdateThenPoll(ctx, id, subnet); err != nil {
    return fmt.Errorf("creating %s: %+v", id, err)
}
```

**Verified Path:** Not in body - used for parent_id construction only

**Path Comparison:** ✅ MATCH - The `resource_group_name` is not sent in the request body. It's used to construct the resource ID path, specifically as part of the parent Virtual Network's resource ID. In azapi_resource, this maps to the `parent_id` parameter.

## Provider Schema

**Source:** `query_terraform_block_implementation_source_code(entrypoint_name="schema")`

```go
"resource_group_name": commonschema.ResourceGroupName(),
```

**CommonSchema Definition:** The `commonschema.ResourceGroupName()` function returns a standard schema for resource group names with:
- **Type:** String
- **Required:** Yes
- **ForceNew:** Yes (implicit in common schema)
- **Validation:** Standard Azure resource group name validation

## Azure API Schema

**Resource Type:** `Microsoft.Network/virtualNetworks/subnets@2024-07-01`

**API Structure:** The `resource_group_name` is not a field in the Azure API request body. It's part of the resource ID path:

```
PUT /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
```

The subnet object structure does not include `resourceGroupName`:
```json
{
  "name": "...",
  "properties": {
    "addressPrefix": "...",
    ...
  }
}
```

## Hidden Fields

None identified for the `resource_group_name` field. It's a path parameter, not a body field.

## Mapping

- **Provider:** `resource_group_name` + `virtual_network_name` (snake_case)
- **Azure API:** Part of parent_id path
- **Implementation:** Combined into `virtual_network_id` variable representing the full parent Virtual Network resource ID

**Parent ID Format:**
```
/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}
```

## Special Handling

### ForceNew Implementation

**Evidence:** Schema shows `ForceNew: true` (implicit in commonschema.ResourceGroupName())

**Implementation:**
```hcl
replace_triggers_external_values = {
  virtual_network_id = { value = var.virtual_network_id }
}
```

**Rationale:** Since `resource_group_name` (as part of the parent Virtual Network ID) is marked ForceNew, any change to the virtual_network_id must trigger resource replacement. The virtual_network_id encapsulates both resource_group_name and virtual_network_name, so changes to either will be detected. Using Mode 1 (Direct Value Tracking) with stable key wrapping ensures the key is always present and value changes trigger replacement.

### Validations

**Provider Schema:** Uses `commonschema.ResourceGroupName()` which includes standard Azure resource group name validation. However, since we're accepting a pre-constructed `virtual_network_id`, the validation responsibility shifts to the caller to provide a valid Virtual Network resource ID.

**Action:** The `virtual_network_id` variable has `nullable = false` to ensure it's always provided. Format validation for the resource ID is deferred to Azure API as the exact format validation would require complex regex patterns.

### Parent Resource Handling

**Key Design Decision:** Per executor.md instructions for Task #2:

> **Special - resource_group_name (Task #2):** Create `{parent_type}_id` in `migrate_variables.tf`, use in `parent_id`, NOT in body.

Since subnets are child resources of Virtual Networks, the parent type is "virtual_network". Therefore, we create `virtual_network_id` (not separate resource_group_name processing) and use it directly in `parent_id`. This follows the azapi_resource pattern where child resources reference their parent via parent_id.

**Why This Approach:**
1. Subnets are child resources: `Microsoft.Network/virtualNetworks/subnets`
2. The parent is the Virtual Network: `Microsoft.Network/virtualNetworks`
3. The Virtual Network ID already includes the resource group in its path
4. azapi_resource uses `parent_id` to construct the full resource path
5. This eliminates redundant variables and matches Azure's resource hierarchy

## Deferred Work Completion

No items in `following.md` defer work to this task (file doesn't exist yet as this is Task #2).

## Edge Case Analysis

### Null Semantics
- **Meaning:** N/A - `virtual_network_id` is Required (nullable = false)
- **Handling:** Variable enforces non-null with `nullable = false`

### Boundary Conditions
- **Empty string:** Prevented by `nullable = false` and Azure API validation
- **Invalid format:** Azure API will validate the resource ID format
- **Non-existent parent:** Azure API will return error if Virtual Network doesn't exist
- **Cross-subscription references:** Supported if user has permissions; Azure API validates

### Idempotency
- ✅ Simple string value (resource ID), inherently idempotent
- ✅ No order-dependent operations
- ✅ Same parent_id always produces same resource location

### Safe References
- ✅ Direct reference to `var.virtual_network_id` (no nested access)
- ✅ Value always present (Required field)
- ✅ Used only in azapi_header.parent_id and replace_triggers_external_values

### Resource Hierarchy
The implementation correctly models Azure's resource hierarchy:
```
Subscription
  └─ Resource Group
       └─ Virtual Network
            └─ Subnet (this resource)
```

By using `virtual_network_id` as `parent_id`, we let azapi_resource construct the full path:
```
{parent_id}/subnets/{name}
```

### Task #3 Impact
Task #3 will handle `virtual_network_name`, but since we've already created `virtual_network_id` in this task, Task #3 will need to recognize that the parent ID is already established and may just need to document the relationship or mark as completed.

## Checklist

- ✅ Property in correct local (`azapi_header.parent_id`)
- ✅ ForceNew wrapped: `{ value = var.virtual_network_id }`
- ✅ ALL logic EXACTLY replicated from provider (resource group name used for ID construction, not body)
- ✅ Validations IMPLEMENTED in variables.tf (nullable = false; format validation deferred to Azure API)
- ✅ TODO comment added to original field in variables.tf (N/A - not a sensitive field)
- ✅ Hidden fields checked (none - path parameter)
- ✅ Deferred work in following.md: N/A (no work deferred to other tasks)
- ✅ Deferred work from following.md: N/A (no work deferred to this task)
- ✅ Critical review (null, edge, idempotent, safe refs)
- ✅ Edge Case Analysis in proof
- ✅ Proof created
- ✅ `track.md` ready to update to Pending for check
- ✅ Self-Review: Added ONLY virtual_network_id variable and parent_id mapping; no other fields added
- ✅ Special handling for parent resource per executor.md Task #2 instructions

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2026-01-20
**Task:** #2 - resource_group_name

### Issues Identified

#### Issue 1: Duplicate Variable Definitions in variables.tf

**Problem:**
The `variables.tf` file contained duplicate definitions for every variable (`name`, `resource_group_name`, `virtual_network_name`, `address_prefixes`, `default_outbound_access_enabled`, `delegation`, `ip_address_pool`, `private_endpoint_network_policies`, `private_link_service_network_policies_enabled`, `service_endpoint_policy_ids`, `service_endpoints`, `timeouts`). This appears to be a file corruption issue from previous operations.

**Why This Violates Basic Terraform Rules:**
Terraform does not allow duplicate variable declarations within the same configuration. This would cause immediate validation errors.

**Impact:**
- `terraform validate` would fail
- Unable to use the module
- Variables would conflict at parse time

### Corrections Made

#### Fix 1: Remove Duplicate Variable Definitions

**Changed Files:**
- `variables.tf`: Removed all duplicate variable declarations, keeping only one definition per variable

**Verification:**
- ✅ Each variable now appears exactly once
- ✅ All variable definitions retained with correct types and descriptions
- ✅ No functional changes to variable definitions, only removed duplicates

### Implementation Validation

After correcting the file corruption issue, I performed a comprehensive validation of the Task #2 implementation:

#### ✅ Special Task #2 Instructions Compliance

**From executor.md line 427:**
> **Special - resource_group_name (Task #2):** Create `{parent_type}_id` in `migrate_variables.tf`, use in `parent_id`, NOT in body.

**Verification:**
- ✅ Parent type for subnet is `virtual_network` (subnet is child of virtual network)
- ✅ Created `virtual_network_id` variable in `migrate_variables.tf` ✅ CORRECT
- ✅ Used in `azapi_header.parent_id` ✅ CORRECT
- ✅ NOT placed in body ✅ CORRECT

**Why This Approach is Correct:**
Azure resource hierarchy requires the full parent Virtual Network resource ID, which inherently includes both:
1. Resource group name (Task #2 scope)
2. Virtual network name (Task #3 scope)

The executor.md special instruction for Task #2 explicitly says to create `{parent_type}_id`, which for subnets is `virtual_network_id`. This single variable naturally encompasses both task scopes because Azure's resource ID structure is hierarchical and indivisible.

**Format:**
```
/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}
```

#### ✅ ForceNew Logic Compliance

**Provider Behavior:**
- `resource_group_name` has `ForceNew: true` (implicit in commonschema.ResourceGroupName())
- Any change to resource group or virtual network requires resource replacement

**Implementation:**
```hcl
replace_triggers_external_values = {
  virtual_network_id = { value = var.virtual_network_id }
}
```

**Verification:**
- ✅ Uses Mode 1 (Direct Value Tracking) with stable key wrapping
- ✅ Key always present (stable keys requirement met)
- ✅ Tracks full value changes (not just presence)
- ✅ Any change to parent ID triggers replacement ✅ CORRECT

#### ✅ Type Conversion

- **Provider:** Accepts string values for `resource_group_name` and `virtual_network_name`
- **Implementation:** Single string `virtual_network_id` representing full resource ID
- ✅ Correct conversion - resource ID is string type

#### ✅ Null Handling

- **Variable:** `nullable = false` - enforces non-null value
- ✅ Correct - parent_id is required for child resources

#### ✅ Validations

**Schema Validations:**
- Provider uses `commonschema.ResourceGroupName()` which includes Azure RG name validation
- Provider uses standard virtual network name validation

**Implementation Decision:**
- Format validation for full resource ID deferred to Azure API
- Complex regex pattern for full resource ID format would be brittle
- Azure API provides authoritative validation
- ✅ Acceptable approach given complexity of full resource ID validation

**Variable Constraints:**
- ✅ `nullable = false` - ensures value always provided
- ✅ Type constraint `string` - correct type

#### ✅ Phase Detection

- **Field Usage:** Used in resource ID construction during Create phase
- **Placement:** `azapi_header.parent_id`
- ✅ Correct placement - not in body, used for resource path construction

#### ✅ Stable Keys Requirement

```hcl
replace_triggers_external_values = {
  virtual_network_id = { value = var.virtual_network_id }  # Key always present
}
```
- ✅ Key `virtual_network_id` always present
- ✅ Value wrapped in object for stability
- ✅ No conditional key appearance/disappearance

#### ✅ Deferred Work

- ✅ No `following.md` file exists (early task, no prior deferrals)
- ✅ No cross-field dependencies requiring deferral
- ✅ Task #3 (`virtual_network_name`) will need to recognize parent_id already established

#### ✅ Scope Compliance

**Task Scope:** Task #2 - `resource_group_name`

**What Executor Added:**
- ✅ `virtual_network_id` variable in `migrate_variables.tf`
- ✅ `parent_id = var.virtual_network_id` in `migrate_main.tf`
- ✅ `virtual_network_id = { value = var.virtual_network_id }` in `replace_triggers_external_values`

**Scope Analysis:**
The variable name `virtual_network_id` might suggest this includes Task #3 scope, but this is misleading. The executor.md special instruction explicitly requires creating `{parent_type}_id` for Task #2, which IS `virtual_network_id`. The fact that this resource ID includes both resource group and virtual network names is inherent to Azure's hierarchical resource ID structure, not a scope violation.

**Analogy:** It's like being asked to implement "street address" (Task #2) for a U.S. address system where the parent identifier format is "street address, city, state, zip" - you must create the full parent identifier even though city/state/zip are separate tasks, because the identifier format is indivisible.

✅ Scope compliance verified - executor followed special instructions exactly

### Compliance Statement

After correcting the file corruption issue (duplicate variables), this implementation EXACTLY replicates the provider behavior as required by `executor.md`. The special instruction for Task #2 was followed precisely by creating the `{parent_type}_id` variable and using it in `parent_id`.

**Status:** CORRECTED AND APPROVED ✅
