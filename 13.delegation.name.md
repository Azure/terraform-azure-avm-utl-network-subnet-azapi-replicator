# Task #13 - delegation.name - Block Argument

## Summary
Implemented `delegation.name` argument within the delegation block structure. This is a Required string field that specifies a name for each subnet delegation. The field maps directly to the Azure API `delegations[*].name` property and has no validation constraints or ForceNew behavior.

## Shadow Implementation
```hcl
locals {
  body = {
    properties = merge(
      # ... other fields ...
      var.delegation != null ? {                                              # <-
        delegations = [                                                       # <-
          for delegation_item in var.delegation : {                           # <-
            name = delegation_item.name                                       # <-
            properties = {                                                    # <-
              # serviceName = ... # Task #15                                 # <-
              # actions = ... # Task #16                                     # <-
            }                                                                 # <-
          }                                                                   # <-
        ]                                                                     # <-
      } : {}                                                                  # <-
    )
  }
}
```

## Create Phase Verification

### Querying Create Method
Queried `resourceSubnetCreate` to identify where delegation.name is processed.

### Provider Create Method Evidence
```go
func resourceSubnetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	properties := subnets.SubnetPropertiesFormat{}
	// ... other fields ...
	
	delegationsRaw := d.Get("delegation").([]interface{})
	properties.Delegations = expandSubnetDelegation(delegationsRaw)

	subnet := subnets.Subnet{
		Name:       pointer.To(id.SubnetName),
		Properties: &properties,
	}

	if err := client.CreateOrUpdateThenPoll(ctx, id, subnet); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}
	// ...
}
```

### Classification
- **Pattern**: Single-phase (only primary `CreateOrUpdateThenPoll`)
- **Field Classification**: Create phase - processed before primary create operation
- **Assignment**: Extracted in `expandSubnetDelegation` and assigned to `delegations[*].Name`

### Decision
The `delegation.name` field is processed in the Create phase and assigned to `local.body.properties.delegations[*].name`.

## Assignment Path Verification

### Predicted Path
`body.properties.delegations[*].name`

### Provider Code Evidence

**Step 1 - Field Retrieval:**
```go
delegationsRaw := d.Get("delegation").([]interface{})
properties.Delegations = expandSubnetDelegation(delegationsRaw)
```

**Step 2 - Expand Function:**
```go
func expandSubnetDelegation(input []interface{}) *[]subnets.Delegation {
	retDelegations := make([]subnets.Delegation, 0)

	for _, deleValue := range input {
		deleData := deleValue.(map[string]interface{})
		deleName := deleData["name"].(string)  // <- Extract name
		srvDelegations := deleData["service_delegation"].([]interface{})
		srvDelegation := srvDelegations[0].(map[string]interface{})
		srvName := srvDelegation["name"].(string)
		srvActions := srvDelegation["actions"].(*pluginsdk.Set).List()

		retSrvActions := make([]string, 0)
		for _, srvAction := range srvActions {
			srvActionData := srvAction.(string)
			retSrvActions = append(retSrvActions, srvActionData)
		}

		retDelegation := subnets.Delegation{
			Name: &deleName,  // <- Assign to delegation Name
			Properties: &subnets.ServiceDelegationPropertiesFormat{
				ServiceName: &srvName,
				Actions:     &retSrvActions,
			},
		}

		retDelegations = append(retDelegations, retDelegation)
	}

	return &retDelegations
}
```

**Step 3 - Struct Assignment:**
```go
properties.Delegations = expandSubnetDelegation(delegationsRaw)  // <- Assign to properties

subnet := subnets.Subnet{
	Name:       pointer.To(id.SubnetName),
	Properties: &properties,  // <- SubnetPropertiesFormat assigned to Properties
}
```

**Step 4 - API Call:**
```go
if err := client.CreateOrUpdateThenPoll(ctx, id, subnet); err != nil {
	return fmt.Errorf("creating %s: %+v", id, err)
}
```

### Trace of Assignments
1. `delegationsRaw` retrieved from Terraform state via `d.Get("delegation")`
2. For each delegation item, `name` extracted: `deleName := deleData["name"].(string)`
3. `deleName` assigned to `Delegation.Name` field in expand function
4. Array of `Delegation` objects assigned to `properties.Delegations`
5. `properties` (type `SubnetPropertiesFormat`) assigned to `subnet.Properties`
6. `subnet` sent to Azure API via `CreateOrUpdateThenPoll`

### Verified Path
`body.properties.delegations[*].name` ✅

### Path Comparison
**Predicted**: `body.properties.delegations[*].name`
**Verified**: `body.properties.delegations[*].name`
**Match**: ✅ YES

## Provider Schema

### Terraform Schema
```go
"delegation": {
	Type:     pluginsdk.TypeList,
	Optional: true,
	Elem: &pluginsdk.Resource{
		Schema: map[string]*pluginsdk.Schema{
			"name": {
				Type:     pluginsdk.TypeString,
				Required: true,  // <- Required field
				// No ForceNew
				// No validation functions
			},
			// ... service_delegation block ...
		},
	},
},
```

**Key Schema Details:**
- `delegation.name`: `TypeString`, `Required: true`
- No `ForceNew: true` - field can be updated without resource replacement
- No `ValidateFunc` - no validation constraints on the name
- No `DiffSuppressFunc` - standard string comparison

## Azure API Schema

### Azure SDK Type
```go
type Delegation struct {
	Etag       *string                            `json:"etag,omitempty"`
	Id         *string                            `json:"id,omitempty"`
	Name       *string                            `json:"name,omitempty"`  // <- Our field
	Properties *ServiceDelegationPropertiesFormat `json:"properties,omitempty"`
	Type       *string                            `json:"type,omitempty"`
}
```

### Azure API Schema Description
From Azure API documentation:
- `delegations`: "An array of references to the delegations on the subnet."
- `delegations[*].name`: String field at delegation object root level

### Property Path
`body.properties.delegations[*].name`

## Hidden Fields
No hidden fields for this specific argument. The delegation object contains computed fields (`id`, `etag`, `type`) but these are at the delegation object level and were already identified in Task #12 (delegation block skeleton).

## Mapping

| Terraform Field | Azure API Field | Notes |
|----------------|-----------------|-------|
| `delegation[*].name` | `delegations[*].name` | Direct mapping, string value |

## Special Handling

### ForceNew Analysis
**Schema Check**: No `ForceNew: true` in schema
**CustomizeDiff Check**: No CustomizeDiff logic related to delegation.name
**Conclusion**: The `delegation.name` field does NOT trigger resource replacement. Users can update delegation names without recreating the subnet.

### Validations
**Schema Validations**: None
**Required Status**: The field is Required within the delegation block (enforced by `Required: true` in schema)

The Required validation is already enforced by the existing `variables.tf` schema definition:
```hcl
variable "delegation" {
  type = list(object({
    name = string  # <- Required: must be provided when delegation block is used
    service_delegation = object({ ... })
  }))
}
```

No additional validation blocks needed - Terraform's type system enforces that `name` must be a non-null string when a delegation object is provided.

### Sensitive Fields
Not applicable - this is a plain string field that is not sensitive.

### Conditional Logic
The field is always included when a delegation item exists (no null check needed on the name itself since it's Required). The parent conditional `var.delegation != null` already gates the entire delegations array.

## Deferred Work Completion
Checked `following.md` - no work was deferred to Task #13.

## Edge Case Analysis

### Null Handling
- **`delegation.name` null**: Impossible - field is Required in schema, Terraform enforces non-null
- **`var.delegation` null**: Parent conditional handles this - delegations array not included in body
- **Empty string `""`**: Allowed by schema (no validation against empty strings), provider will send to API

### Empty Collections
Not applicable - this is a string field, not a collection.

### Idempotency
- **Direct value assignment**: `name = delegation_item.name` ensures same input produces same output
- **No transformations**: Value passed through unchanged to API
- **Deterministic**: No order-dependent logic

### Safe References
- **Parent null check**: `var.delegation != null` prevents iteration over null
- **Required field**: `delegation_item.name` always exists when delegation_item exists (enforced by schema)
- **Direct access**: No nested navigation that could fail on null

### Boundary Conditions
- **Empty string**: Provider allows, API may accept or reject (API validation)
- **Long strings**: No length validation in provider
- **Special characters**: No character restrictions in provider schema

## Checklist

- ✅ Property in correct local (`body.properties.delegations[*].name`)
- ✅ ForceNew analysis complete (not a ForceNew field)
- ✅ All logic exactly replicated from provider (direct value assignment)
- ✅ Validations assessed (Required status enforced by type system, no additional validations needed)
- ✅ Hidden fields checked (none for this specific field)
- ✅ Deferred work checked (none from following.md)
- ✅ Critical review complete (null handling, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis documented
- ✅ Proof document created
- ✅ track.md will be updated to "Pending for check"
- ✅ Self-review: Only delegation.name implemented, no other fields touched

## Critical Review Summary

**Implementation Exactly Matches Provider Behavior:**
1. ✅ Schema: Required string field with no validation
2. ✅ Expand logic: Direct extraction `deleName := deleData["name"].(string)` → `Name: &deleName`
3. ✅ API assignment: Placed in delegation object at root level (not in properties)
4. ✅ No ForceNew: Field can be updated without resource replacement
5. ✅ No DiffSuppressFunc: Standard string equality comparison
6. ✅ No transformations: Value passed through unchanged

**No deviations, shortcuts, or conservative approaches taken. This is an EXACT replication of provider behavior.**

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent  
**Date:** 2026-01-20  
**Task:** #13 - delegation.name

### Validation Results

✅ **Schema Compliance:** Field correctly identified as `Required: true`, `TypeString`, no ForceNew, no validations  
✅ **Phase Detection:** Correctly classified as Create phase field, placed in `local.body.properties.delegations[*].name`  
✅ **Assignment Path Verification:** Complete trace from schema → expand function → struct assignment → API call. Path verified as `body.properties.delegations[*].name` ✅  
✅ **Type Conversion:** Direct string assignment, no conversion needed  
✅ **Null Handling:** Parent conditional `var.delegation != null` correctly gates the entire delegations array. Field is Required so always present when delegation item exists  
✅ **ForceNew Logic:** Not a ForceNew field (no schema ForceNew, no CustomizeDiff logic) - correctly omitted from `replace_triggers_external_values`  
✅ **Stable Keys:** Not applicable (not a ForceNew field)  
✅ **Validations:** Required status correctly enforced by Terraform type system (`name = string` in object type definition). No additional validations needed  
✅ **Deferred Work Completion:** Checked `following.md` - no work deferred to Task #13  
✅ **Deferred Work Recording:** No deferrals made by this task  
✅ **Sensitive Fields:** Not applicable - plain string field  
✅ **Shared Path Merge Check:** No merge conflicts - delegation block uses separate conditional branch  
✅ **Edge Cases:** Properly analyzed - null handling, empty string behavior, idempotency, safe references all correct  
✅ **Proof Document Quality:** Complete with all required sections, no forbidden phrases, exact replication documented

### Implementation Analysis

**Code Review:**
```hcl
# migrate_main.tf lines 72-82
var.delegation != null ? {
  delegations = [
    for delegation_item in var.delegation : {
      name = delegation_item.name  # <- Direct assignment, exactly matches provider
      properties = {
        # serviceName = ... # Task #15
        # actions = ... # Task #16
      }
    }
  ]
} : {}
```

**Provider Behavior Match:**
The implementation EXACTLY replicates the provider's expand function:
1. ✅ Iterates over delegation list
2. ✅ Extracts `name` field: `deleName := deleData["name"].(string)`
3. ✅ Assigns to delegation object: `Name: &deleName`
4. ✅ Places in properties.delegations array
5. ✅ No transformations applied

**Type System Enforcement:**
Variable definition in `variables.tf` correctly enforces Required status:
```hcl
variable "delegation" {
  type = list(object({
    name = string  # Required: non-nullable string
    service_delegation = object({ ... })
  }))
}
```

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The field is:
- Required within delegation block (enforced by type system)
- Has no validations (none in provider schema)
- Has no ForceNew behavior (correctly omitted)
- Has no DiffSuppressFunc (standard equality)
- Uses direct value assignment (no transformations)
- Correctly placed in Create phase (`local.body`)

No deviations, simplifications, or "safer alternatives" were found. The implementation follows all executor.md rules:
- ✅ Exact replication achieved
- ✅ No prohibited patterns found
- ✅ Method priority followed (N/A - single approach)
- ✅ Cross-variable validation rules followed (N/A)
- ✅ AzAPI 2.0+ patterns used correctly
- ✅ All mandatory checks completed

**Status:** APPROVED ✅

---
