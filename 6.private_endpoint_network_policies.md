# Task #6 - private_endpoint_network_policies - COMPLETED

## Summary
Successfully implemented `private_endpoint_network_policies` argument conversion from azurerm_subnet to azapi_resource. The field is an Optional string with a default value of "Disabled" and supports four possible values: Disabled, Enabled, NetworkSecurityGroupEnabled, and RouteTableEnabled. The implementation replicates the exact provider behavior including the default value, validation, and direct assignment to the Azure API property.

## Shadow Implementation
```hcl
# variables.tf
variable "private_endpoint_network_policies" {
  type        = string
  default     = "Disabled"                                                    # <-
  nullable    = false                                                        # <-
  description = "(Optional) Enable or Disable network policies for the private endpoint on the subnet. Possible values are `Disabled`, `Enabled`, `NetworkSecurityGroupEnabled` and `RouteTableEnabled`. Defaults to `Disabled`."

  validation {                                                               # <-
    condition = contains([                                                   # <-
      "Disabled",                                                            # <-
      "Enabled",                                                             # <-
      "NetworkSecurityGroupEnabled",                                         # <-
      "RouteTableEnabled"                                                    # <-
    ], var.private_endpoint_network_policies)                               # <-
    error_message = "private_endpoint_network_policies must be one of: Disabled, Enabled, NetworkSecurityGroupEnabled, RouteTableEnabled."  # <-
  }                                                                          # <-
}

# migrate_main.tf
locals {
  body = {
    properties = merge(
      local.address_prefix_singular != null ? { addressPrefix = local.address_prefix_singular } : {},
      local.address_prefixes_plural != null ? { addressPrefixes = local.address_prefixes_plural } : {},
      { defaultOutboundAccess = var.default_outbound_access_enabled },
      { privateEndpointNetworkPolicies = var.private_endpoint_network_policies }  # <-
    )
  }
}
```

## Create Phase Verification

### Query Create Method
```go
func resourceSubnetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ... setup code ...

	properties := subnets.SubnetPropertiesFormat{}
	
	// ... other property assignments ...

	// To enable private endpoints you must disable the network policies for the subnet because
	// Network policies like network security groups are not supported by private endpoints.
	var privateEndpointNetworkPolicies subnets.VirtualNetworkPrivateEndpointNetworkPolicies
	var privateLinkServiceNetworkPolicies subnets.VirtualNetworkPrivateLinkServiceNetworkPolicies

	privateEndpointNetworkPoliciesRaw := d.Get("private_endpoint_network_policies").(string)
	privateLinkServiceNetworkPoliciesRaw := d.Get("private_link_service_network_policies_enabled").(bool)

	privateEndpointNetworkPolicies = subnets.VirtualNetworkPrivateEndpointNetworkPolicies(privateEndpointNetworkPoliciesRaw)
	privateLinkServiceNetworkPolicies = subnets.VirtualNetworkPrivateLinkServiceNetworkPolicies(expandSubnetNetworkPolicy(privateLinkServiceNetworkPoliciesRaw))

	properties.PrivateEndpointNetworkPolicies = pointer.To(privateEndpointNetworkPolicies)
	properties.PrivateLinkServiceNetworkPolicies = pointer.To(privateLinkServiceNetworkPolicies)

	// ... other property assignments ...

	subnet := subnets.Subnet{
		Name:       pointer.To(id.SubnetName),
		Properties: &properties,
	}

	if err := client.CreateOrUpdateThenPoll(ctx, id, subnet); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}

	// ... wait for provisioning states ...
}
```

### Pattern Classification
The subnet resource follows a **single-phase creation pattern**: the primary `CreateOrUpdateThenPoll` operation creates the subnet with all properties including `private_endpoint_network_policies`.

### Field Phase Classification
The `private_endpoint_network_policies` field is assigned BEFORE the primary create operation:
- Retrieved from Terraform state: `d.Get("private_endpoint_network_policies").(string)`
- Directly cast to SDK enum type: `subnets.VirtualNetworkPrivateEndpointNetworkPolicies(privateEndpointNetworkPoliciesRaw)`
- Assigned to properties: `properties.PrivateEndpointNetworkPolicies = pointer.To(privateEndpointNetworkPolicies)`
- Included in the primary `CreateOrUpdateThenPoll` call

**Decision:** This is a **Create phase** field - belongs in `local.body`.

## Assignment Path Verification

### Predicted Path
`body.properties.privateEndpointNetworkPolicies`

### Go Code Evidence
```go
// Step 1: Field assigned to SubnetPropertiesFormat
properties := subnets.SubnetPropertiesFormat{}
privateEndpointNetworkPoliciesRaw := d.Get("private_endpoint_network_policies").(string)
privateEndpointNetworkPolicies = subnets.VirtualNetworkPrivateEndpointNetworkPolicies(privateEndpointNetworkPoliciesRaw)
properties.PrivateEndpointNetworkPolicies = pointer.To(privateEndpointNetworkPolicies)

// Step 2: Properties struct assigned to Subnet
subnet := subnets.Subnet{
	Name:       pointer.To(id.SubnetName),
	Properties: &properties,  // <- Properties becomes nested under "properties" in JSON
}

// Step 3: Subnet sent to API
client.CreateOrUpdateThenPoll(ctx, id, subnet)
```

### Verified Path
- `privateEndpointNetworkPolicies` field in `SubnetPropertiesFormat` struct
- `SubnetPropertiesFormat` assigned to `Subnet.Properties` field
- In JSON/API: `properties.privateEndpointNetworkPolicies`

### Path Comparison
✅ **MATCH** - Predicted path `body.properties.privateEndpointNetworkPolicies` matches the verified path from Go code.

## Provider Schema

### Schema Definition
```go
"private_endpoint_network_policies": {
	Type:         pluginsdk.TypeString,
	Optional:     true,
	Default:      string(subnets.VirtualNetworkPrivateEndpointNetworkPoliciesDisabled),
	ValidateFunc: validation.StringInSlice(subnets.PossibleValuesForVirtualNetworkPrivateEndpointNetworkPolicies(), false),
}
```

### Key Properties
- **Type:** String
- **Required:** No (Optional: true)
- **Default:** `"Disabled"` (via `subnets.VirtualNetworkPrivateEndpointNetworkPoliciesDisabled` constant)
- **ForceNew:** No
- **Validation:** `StringInSlice` with possible values from SDK enum
- **Computed:** No
- **Sensitive:** No

### Update Behavior
```go
func resourceSubnetUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	if d.HasChange("private_endpoint_network_policies") {
		v := d.Get("private_endpoint_network_policies").(string)
		props.PrivateEndpointNetworkPolicies = pointer.To(subnets.VirtualNetworkPrivateEndpointNetworkPolicies(v))
	}
	// ... update via CreateOrUpdateThenPoll
}
```

The field can be updated in-place without forcing replacement.

## Azure API Schema

### Property Path
`properties.privateEndpointNetworkPolicies`

### API Schema Type
```
String
```

### API Documentation
From Azure API version 2024-07-01:
```
"privateEndpointNetworkPolicies": "Enable or Disable apply network policies on private end point in the subnet. (Possible values: Enabled,Disabled,NetworkSecurityGroupEnabled,RouteTableEnabled)"
```

### Valid Values
- `Disabled`
- `Enabled`
- `NetworkSecurityGroupEnabled`
- `RouteTableEnabled`

## Hidden Fields
None. This is a standard user-facing argument with no hidden values.

## Mapping

### Terraform (azurerm_subnet) → Azure API
- **Terraform argument:** `private_endpoint_network_policies` (snake_case)
- **Azure API property:** `privateEndpointNetworkPolicies` (camelCase)
- **Transformation:** Direct string value assignment (no transformation needed)

## Special Handling

### Default Value
The provider schema specifies:
```go
Default: string(subnets.VirtualNetworkPrivateEndpointNetworkPoliciesDisabled)
```

This resolves to the string `"Disabled"`. 

**Implementation:**
```hcl
variable "private_endpoint_network_policies" {
  type        = string
  default     = "Disabled"
  nullable    = false  # CRITICAL: Root-level argument with default must have nullable = false
  # ...
}
```

**Rationale:** Per executor.md rules for defaults - root-level arguments with defaults MUST have both `default` value AND `nullable = false` set.

### Validation
The provider uses `validation.StringInSlice(subnets.PossibleValuesForVirtualNetworkPrivateEndpointNetworkPolicies(), false)` which enforces the four valid enum values.

**Implementation:**
```hcl
validation {
  condition = contains([
    "Disabled",
    "Enabled",
    "NetworkSecurityGroupEnabled",
    "RouteTableEnabled"
  ], var.private_endpoint_network_policies)
  error_message = "private_endpoint_network_policies must be one of: Disabled, Enabled, NetworkSecurityGroupEnabled, RouteTableEnabled."
}
```

### ForceNew
No ForceNew behavior. The field can be updated in-place as evidenced by the Update method handling changes.

### Sensitive
Not a sensitive field.

### DiffSuppressFunc
No DiffSuppressFunc defined for this field in the provider schema.

## Deferred Work Completion
Checked `following.md` - no work was deferred to Task #6.

## Edge Case Analysis

### Null Semantics
The field has `default = "Disabled"` and `nullable = false`, so null is not a valid state. The variable will always have the value "Disabled" if not explicitly set by the user.

### Empty String
The validation ensures only the four specific enum values are accepted. An empty string would fail validation.

### Default Behavior
When users don't specify this argument:
- Provider behavior: Uses default "Disabled"
- Our implementation: Variable defaults to "Disabled"
- Result: ✅ Identical behavior

### Value Changes
Users can change between any of the four valid values:
- Provider: Allows in-place updates (no ForceNew)
- Our implementation: Updates the `body.properties.privateEndpointNetworkPolicies` value
- Result: ✅ Identical behavior

### Invalid Values
If user provides an invalid value:
- Provider: Validation fails at plan time with StringInSlice error
- Our implementation: Validation block fails at plan time with clear error message
- Result: ✅ Both fail fast at plan time

### Idempotency
Direct string assignment is idempotent - applying the same value multiple times produces the same result.

## Critical Review

### Exact Replication Verification
✅ **Default Value:** Exact match - "Disabled"
✅ **Validation:** Exact match - four enum values enforced
✅ **ForceNew:** Exact match - no ForceNew behavior
✅ **Update Support:** Exact match - in-place updates allowed
✅ **Type:** Exact match - string
✅ **Nullable:** Correctly set to false for root-level default

### No Compromises
This implementation contains NO phrases like:
- ❌ "more conservative than provider"
- ❌ "simpler approach"
- ❌ "close enough"
- ❌ "acceptable because"

Every aspect replicates exact provider behavior.

## Checklist

- ✅ Property in correct local (`body`)
- ✅ Default value replicated (`"Disabled"` with `nullable = false`)
- ✅ Validation implemented in variables.tf (enum values)
- ✅ No ForceNew handling needed (field is updatable)
- ✅ Not sensitive
- ✅ Hidden fields checked (none)
- ✅ Deferred work checked (none to this task)
- ✅ Critical review completed
- ✅ Edge Case Analysis included
- ✅ Proof document created
- ✅ track.md ready to update
- ✅ Self-review: Only Task #6 content added, no other fields included

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-20
**Task:** #6 - private_endpoint_network_policies

### Validation Results

✅ **ForceNew Logic:** Not applicable - field is updatable in-place (no ForceNew behavior)
✅ **Stable Keys:** Not applicable - field not in replace_triggers_external_values
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase)
✅ **Type Conversion:** Correct - string to string (direct assignment)
✅ **Null Handling:** Correctly enforced - `nullable = false` with `default = "Disabled"`
✅ **Validations:** All provider validations implemented - StringInSlice enum validation with 4 valid values
✅ **Root-Level Default:** CRITICAL requirement met - both `default = "Disabled"` AND `nullable = false` set (per executor.md line 405-434)
✅ **Deferred Work Completion:** No deferred work for this task (checked following.md)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed - null semantics, empty string, invalid values, idempotency
✅ **Method Priority:** Not applicable - no multiple methods involved
✅ **Shared Path Merge:** Not applicable - no merge conflicts in this implementation
✅ **Assignment Path:** Correctly verified through Go code trace to `properties.privateEndpointNetworkPolicies`

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found. The implementation correctly:
- Uses the exact default value "Disabled" from provider constant
- Enforces the exact four enum values via validation
- Sets `nullable = false` as mandated for root-level defaults
- Places the field in the correct phase (Create, via local.body)
- Maps the field name correctly (snake_case to camelCase)

**Status:** APPROVED ✅

---
