# Task #14 - delegation.service_delegation Block - Structure Skeleton

## Summary
Verified structure skeleton for `delegation.service_delegation` block. This is a nested block within the delegation block (with `MaxItems: 1`) that contains service delegation configuration. The block maps to the Azure API `delegations[*].properties` object and contains comment placeholders for child fields (`serviceName`, `actions`) to be implemented by subsequent tasks (#15, #16).

## Shadow Implementation
```hcl
locals {
  body = {
    properties = merge(
      # ... other fields ...
      var.delegation != null ? {                                              # <-
        delegations = [                                                       # <-
          for delegation_item in var.delegation : {                           # <-
            name = delegation_item.name                                       # <-
            properties = {                                                    # <-
              # serviceName = ... # Task #15                                 # <-
              # actions = ... # Task #16                                     # <-
            }                                                                 # <-
          }                                                                   # <-
        ]                                                                     # <-
      } : {}                                                                  # <-
    )
  }
}
```

## Create Phase Verification

### Querying Create Method
Queried `resourceSubnetCreate` to identify where delegation.service_delegation is processed.

### Provider Create Method Evidence
```go
func resourceSubnetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	properties := subnets.SubnetPropertiesFormat{}
	// ... other fields ...
	
	delegationsRaw := d.Get("delegation").([]interface{})
	properties.Delegations = expandSubnetDelegation(delegationsRaw)

	subnet := subnets.Subnet{
		Name:       pointer.To(id.SubnetName),
		Properties: &properties,
	}

	if err := client.CreateOrUpdateThenPoll(ctx, id, subnet); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}
	// ...
}
```

### Classification
- **Pattern**: Single-phase (only primary `CreateOrUpdateThenPoll`)
- **Field Classification**: Create phase - processed before primary create operation
- **Assignment**: Extracted in `expandSubnetDelegation` and assigned to `delegations[*].Properties`

### Decision
The `delegation.service_delegation` block is processed in the Create phase and assigned to `local.body.properties.delegations[*].properties`.

## Assignment Path Verification

### Predicted Path
`body.properties.delegations[*].properties`

### Provider Code Evidence

**Step 1 - Field Retrieval:**
```go
delegationsRaw := d.Get("delegation").([]interface{})
properties.Delegations = expandSubnetDelegation(delegationsRaw)
```

**Step 2 - Expand Function:**
```go
func expandSubnetDelegation(input []interface{}) *[]subnets.Delegation {
	retDelegations := make([]subnets.Delegation, 0)

	for _, deleValue := range input {
		deleData := deleValue.(map[string]interface{})
		deleName := deleData["name"].(string)
		srvDelegations := deleData["service_delegation"].([]interface{})  // <- Extract service_delegation block
		srvDelegation := srvDelegations[0].(map[string]interface{})       // <- MaxItems: 1, take first element
		srvName := srvDelegation["name"].(string)
		srvActions := srvDelegation["actions"].(*pluginsdk.Set).List()

		retSrvActions := make([]string, 0)
		for _, srvAction := range srvActions {
			srvActionData := srvAction.(string)
			retSrvActions = append(retSrvActions, srvActionData)
		}

		retDelegation := subnets.Delegation{
			Name: &deleName,
			Properties: &subnets.ServiceDelegationPropertiesFormat{  // <- Properties object
				ServiceName: &srvName,                               // <- serviceName field
				Actions:     &retSrvActions,                         // <- actions field
			},
		}

		retDelegations = append(retDelegations, retDelegation)
	}

	return &retDelegations
}
```

**Step 3 - Struct Assignment:**
```go
properties.Delegations = expandSubnetDelegation(delegationsRaw)  // <- Assign to properties

subnet := subnets.Subnet{
	Name:       pointer.To(id.SubnetName),
	Properties: &properties,  // <- SubnetPropertiesFormat assigned to Properties
}
```

**Step 4 - API Call:**
```go
if err := client.CreateOrUpdateThenPoll(ctx, id, subnet); err != nil {
	return fmt.Errorf("creating %s: %+v", id, err)
}
```

### Trace of Assignments
1. `delegationsRaw` retrieved from Terraform state via `d.Get("delegation")`
2. For each delegation item, `service_delegation` extracted: `srvDelegations := deleData["service_delegation"].([]interface{})`
3. First element accessed (MaxItems: 1): `srvDelegation := srvDelegations[0].(map[string]interface{})`
4. `serviceName` and `actions` extracted from service_delegation
5. ServiceDelegationPropertiesFormat object created and assigned to `Delegation.Properties`
6. Array of `Delegation` objects assigned to `properties.Delegations`
7. `properties` (type `SubnetPropertiesFormat`) assigned to `subnet.Properties`
8. `subnet` sent to Azure API via `CreateOrUpdateThenPoll`

### Verified Path
`body.properties.delegations[*].properties` ✅

### Path Comparison
**Predicted**: `body.properties.delegations[*].properties`
**Verified**: `body.properties.delegations[*].properties`
**Match**: ✅ YES

## Provider Schema

### Terraform Schema
```go
"delegation": {
	Type:     pluginsdk.TypeList,
	Optional: true,
	Elem: &pluginsdk.Resource{
		Schema: map[string]*pluginsdk.Schema{
			"name": {
				Type:     pluginsdk.TypeString,
				Required: true,
			},
			"service_delegation": {                        // <- This block
				Type:     pluginsdk.TypeList,
				Required: true,                             // <- Required within delegation
				MaxItems: 1,                                // <- Only one service_delegation per delegation
				Elem: &pluginsdk.Resource{
					Schema: map[string]*pluginsdk.Schema{
						"name": {
							Type:         pluginsdk.TypeString,
							Required:     true,
							ValidateFunc: validation.StringInSlice(subnetDelegationServiceNames, false),
						},
						"actions": {
							Type:     pluginsdk.TypeSet,
							Optional: true,
							Elem: &pluginsdk.Schema{
								Type: pluginsdk.TypeString,
								ValidateFunc: validation.StringInSlice([...], false),
							},
						},
					},
				},
			},
		},
	},
},
```

**Key Schema Details:**
- `delegation.service_delegation`: `TypeList`, `Required: true`, `MaxItems: 1`
- This is a Required block within the delegation block
- Contains two fields: `name` (Required) and `actions` (Optional)
- MaxItems: 1 means only one service_delegation per delegation item

## Azure API Schema

### Azure SDK Type
```go
type Delegation struct {
	Etag       *string                            `json:"etag,omitempty"`
	Id         *string                            `json:"id,omitempty"`
	Name       *string                            `json:"name,omitempty"`
	Properties *ServiceDelegationPropertiesFormat `json:"properties,omitempty"`  // <- service_delegation maps here
	Type       *string                            `json:"type,omitempty"`
}

type ServiceDelegationPropertiesFormat struct {
	Actions           *[]string          `json:"actions,omitempty"`       // <- actions field
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty"`  // <- Hidden/computed
	ServiceName       *string            `json:"serviceName,omitempty"`    // <- name field (serviceName in API)
}
```

### Property Path
`body.properties.delegations[*].properties`

The service_delegation block in Terraform maps to the `properties` object within each delegation item in the Azure API.

## Hidden Fields

### Identified Hidden Fields in Azure API

**In ServiceDelegationPropertiesFormat:**
1. `provisioningState` - Provisioning state of the delegation (omitempty, computed by Azure, read-only)

**Provider Behavior:**
The `expandSubnetDelegation` function ONLY sets:
- `Properties.ServiceName` (from `service_delegation.name`)
- `Properties.Actions` (from `service_delegation.actions`)

The `provisioningState` field is computed/managed by Azure and NOT set by the provider.

**Conclusion:** No hidden fields need to be added to the skeleton. The provider does not set any additional fields beyond what's exposed in the Terraform schema. The `provisioningState` is read-only and handled by Azure.

## Mapping

| Terraform Field | Azure API Field | Notes |
|----------------|-----------------|-------|
| `delegation[*].service_delegation` (block) | `delegations[*].properties` (object) | Nested object within delegation |
| `delegation[*].service_delegation.name` | `delegations[*].properties.serviceName` | Service name (camelCase in API) |
| `delegation[*].service_delegation.actions` | `delegations[*].properties.actions` | Action list |
| N/A | `delegations[*].properties.provisioningState` | Hidden - computed by Azure |

## Special Handling

### Block Structure
- **Type**: List block with `MaxItems: 1` (single service_delegation per delegation)
- **Required**: Yes - Required within delegation block
- **Nesting**: Nested within delegation block, maps to properties object in Azure API
- **Transformation**: The Terraform variable structure uses an object (not a list) since it's MaxItems: 1

### Variable Structure
From variables.tf:
```hcl
variable "delegation" {
  type = list(object({
    name = string
    service_delegation = object({      # <- Not a list, but an object (MaxItems: 1)
      actions = optional(set(string))
      name    = string
    })
  }))
}
```

Note: The variable uses `object({...})` not `list(object({...}))` because MaxItems: 1 allows the schema to be simplified.

### Access Pattern
In the locals, we access it as:
- `delegation_item.service_delegation.name` (not `delegation_item.service_delegation[0].name`)
- `delegation_item.service_delegation.actions`

This is because the Terraform schema with MaxItems: 1 is exposed as a list in the SDK, but the provider expand function accesses it using `[0]` indexing.

### ForceNew Analysis
**Schema Check**: No `ForceNew: true` on service_delegation block or its fields
**CustomizeDiff Check**: No CustomizeDiff logic for service_delegation
**Conclusion**: service_delegation fields do NOT trigger resource replacement

### Validations
All validations will be handled by child tasks:
- Task #15: `service_delegation.name` (Required, validated against service names - already in variables.tf)
- Task #16: `service_delegation.actions` (Optional, validated against action list - already in variables.tf)

### Conditional Logic
The service_delegation block is Required within delegation, so whenever `var.delegation != null`, the `properties` object must exist. However, it can be empty if child fields are not yet implemented (using comment placeholders).

## Child Tasks Ready for Delegation

Based on track.md, the following child tasks are now ready to be worked on:
- **Task #15**: `delegation.service_delegation.name` - Implement service delegation name field (maps to `serviceName` in API)
- **Task #16**: `delegation.service_delegation.actions` - Implement service delegation actions field

**Both child tasks (#15, #16) can now proceed** since the parent block structure skeleton is verified and complete.

## Edge Case Analysis

### Null Handling
- **`var.delegation == null`**: Entire `delegations` array omitted from API payload (handled by parent conditional)
- **`service_delegation` null**: Impossible - field is Required within delegation block, enforced by schema
- **Empty `properties` object**: Sent to API as `properties: {}` - API may reject if required fields missing

### Empty Collections
- **Empty actions set**: Expand function creates empty array `[]` - valid Azure API input

### Idempotency
- **Deterministic output**: Same input always produces same output structure
- **No order dependencies**: Field access is direct, not order-dependent

### Safe References
- **Parent null check**: `var.delegation != null` prevents attempting to iterate over null
- **Required block**: `delegation_item.service_delegation` always exists when delegation_item exists (enforced by schema)
- **MaxItems: 1 handling**: Provider expand function safely accesses `[0]` because schema guarantees MaxItems: 1

### Boundary Conditions
- **MaxItems: 1 enforcement**: Schema enforces only one service_delegation per delegation
- **Required block**: Must be provided when delegation is used
- **Variable structure**: Uses object type, not list type, because MaxItems: 1

## Checklist

- ✅ Skeleton structure verified with conditional check
- ✅ Comment placeholders confirmed for child fields with task numbers
- ✅ Create phase verified (single-phase, Create phase)
- ✅ Assignment path verified (body.properties.delegations[*].properties)
- ✅ Hidden fields checked (provisioningState is computed, not set by provider)
- ✅ Expand function analyzed (no hidden logic, only serviceName and actions set)
- ✅ Edge cases analyzed (null, empty, idempotency, safe refs)
- ✅ Child tasks identified (#15, #16 are ready)
- ✅ ForceNew analysis (no ForceNew behavior)
- ✅ Validations deferred to child tasks
- ✅ Self-review: Only skeleton verified, no implementation of child fields
- ✅ track.md will be updated to "Pending for check"

## Critical Review Summary

**Implementation Exactly Matches Provider Behavior:**
1. ✅ Schema: Required list block with MaxItems: 1, contains name and actions fields
2. ✅ Variable structure: Uses object type (not list) because MaxItems: 1
3. ✅ Expand logic: Accesses service_delegation with `[0]` indexing, extracts serviceName and actions
4. ✅ API assignment: Maps to delegations[*].properties object
5. ✅ Hidden fields: provisioningState correctly omitted (computed by Azure)
6. ✅ Structure: properties object created with comment placeholders for child fields
7. ✅ No transformations at block level: Block structure passes through to API as properties object

**The structure skeleton is complete and correct. No modifications needed. This is an EXACT replication of provider structure.**

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-20
**Task:** #14 - delegation.service_delegation

### Validation Results

✅ **Block Structure Skeleton:** Correct conditional skeleton with comment placeholders for child fields (Task #15, #16)
✅ **Parent Block Exists:** delegation block skeleton exists (verified via proof and migrate_main.tf)
✅ **Conditional Logic:** Properly uses `var.delegation != null` check
✅ **Phase Detection:** Correctly placed in Create phase within `local.body.properties`
✅ **Assignment Path:** Verified as `body.properties.delegations[*].properties` - matches provider expand function
✅ **Type Conversion:** MaxItems: 1 correctly handled - variable uses object type, expand accesses [0]
✅ **Hidden Fields:** provisioningState correctly identified as computed/read-only, NOT added to skeleton
✅ **Null Handling:** Safe iteration with parent null check
✅ **Deferred Work Completion:** No deferred work for this task in following.md
✅ **Deferred Work Recording:** No deferrals made (structure skeleton only)
✅ **Edge Cases:** Properly analyzed - null handling, required block enforcement, MaxItems: 1 constraint
✅ **Scope Verification:** Only skeleton implemented, no child field implementations (correct for Type 3)
✅ **Proof Document:** Complete with all required sections, Go code evidence, path verification

### Type 3 Task Compliance

✅ **Skeleton Only:** Creates structure without implementing child fields
✅ **Comment Placeholders:** Present for both child fields with correct task numbers
✅ **No Premature Implementation:** Did not implement fields belonging to Task #15, #16
✅ **Expand Function Checked:** Hidden fields analyzed (none found except computed provisioningState)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The structure skeleton correctly maps `delegation.service_delegation` block to `delegations[*].properties` object in the Azure API, maintains conditional presence, uses proper MaxItems: 1 handling, and provides comment placeholders for child fields. No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
