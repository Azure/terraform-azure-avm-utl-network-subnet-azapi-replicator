# Task #11: Check Root Hidden Fields

## Summary
Analysis of the `azurerm_subnet` Create method reveals NO hidden/hardcoded fields in the root properties block. All fields are user-controlled via schema. The resource follows a **single-phase pattern** with only one SDK operation (`CreateOrUpdateThenPoll`). Locks were identified and implemented.

## Shadow Implementation

```hcl
locals {
  # Extract virtual network name from parent_id for locks  # <-
  virtual_network_name = split("/", var.virtual_network_id)[8]  # <-
  
  locks = [  # <-
    "azurerm_virtual_network.${local.virtual_network_name}"  # <-
  ]  # <-
}
```

## Create Phase Verification

### Pattern Identification
**Single-Phase Pattern** - The Create method contains only ONE SDK operation:
1. Primary create: `client.CreateOrUpdateThenPoll(ctx, id, subnet)`

After the primary create, there are only state refresh waiters (not actual resource operations):
- `SubnetProvisioningStateRefreshFunc` - waits for subnet provisioning state
- `VirtualNetworkProvisioningStateRefreshFunc` - waits for vnet provisioning state

These are polling/waiting operations, NOT additional resource creation/update operations.

### Go Code Evidence - Create Method

```go
func resourceSubnetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ... setup code ...

	properties := subnets.SubnetPropertiesFormat{}
	
	// All properties are populated from d.GetOk() - user-controlled
	if value, ok := d.GetOk("address_prefixes"); ok {
		var addressPrefixes []string
		for _, item := range value.([]interface{}) {
			addressPrefixes = append(addressPrefixes, item.(string))
		}
		properties.AddressPrefixes = &addressPrefixes
	}
	
	// ... more d.GetOk() calls for other fields ...
	
	properties.DefaultOutboundAccess = pointer.To(d.Get("default_outbound_access_enabled").(bool))
	delegationsRaw := d.Get("delegation").([]interface{})
	properties.Delegations = expandSubnetDelegation(delegationsRaw)

	subnet := subnets.Subnet{
		Name:       pointer.To(id.SubnetName),
		Properties: &properties,
	}

	// ONLY SDK operation - single-phase
	if err := client.CreateOrUpdateThenPoll(ctx, id, subnet); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}

	// Subsequent code is only state refresh waiters, NOT resource operations
	timeout, _ := ctx.Deadline()
	stateConf := &pluginsdk.StateChangeConf{
		Pending:    []string{string(subnets.ProvisioningStateUpdating)},
		Target:     []string{string(subnets.ProvisioningStateSucceeded)},
		Refresh:    SubnetProvisioningStateRefreshFunc(ctx, client, id),
		// ... waiter config ...
	}
	if _, err = stateConf.WaitForStateContext(ctx); err != nil {
		return fmt.Errorf("waiting for provisioning state of %s: %+v", id, err)
	}

	// ... more waiters ...
	
	return resourceSubnetRead(d, meta)
}
```

### Decision
**No hidden fields found.** Every property in the `SubnetPropertiesFormat` struct is populated from `d.GetOk()` or `d.Get()`, meaning all values come from user input via the Terraform schema. There are no hardcoded values, computed values, or hidden fields added by the provider.

## Locks Detection

### Lock Analysis
The provider implements locks to prevent concurrent modifications to the Virtual Network resource. This is necessary because subnets are child resources of virtual networks.

### Go Code Evidence - Create Method

```go
func resourceSubnetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ... setup code ...
	
	locks.ByName(id.VirtualNetworkName, VirtualNetworkResourceName)
	defer locks.UnlockByName(id.VirtualNetworkName, VirtualNetworkResourceName)
	
	// ... resource creation ...
}
```

### Go Code Evidence - Update Method

```go
func resourceSubnetUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ... setup code ...
	
	locks.ByName(id.VirtualNetworkName, VirtualNetworkResourceName)
	defer locks.UnlockByName(id.VirtualNetworkName, VirtualNetworkResourceName)

	locks.ByName(id.SubnetName, SubnetResourceName)
	defer locks.UnlockByName(id.SubnetName, SubnetResourceName)
	
	// ... resource update ...
}
```

### Go Code Evidence - Delete Method

```go
func resourceSubnetDelete(d *pluginsdk.ResourceData, meta interface{}) error {
	// ... setup code ...
	
	locks.ByName(id.VirtualNetworkName, VirtualNetworkResourceName)
	defer locks.UnlockByName(id.VirtualNetworkName, VirtualNetworkResourceName)

	locks.ByName(id.SubnetName, SubnetResourceName)
	defer locks.UnlockByName(id.SubnetName, SubnetResourceName)
	
	// ... resource deletion ...
}
```

### Go Code Evidence - Lock Constants

```go
var VirtualNetworkResourceName = "azurerm_virtual_network"
var SubnetResourceName = "azurerm_subnet"
```

### Lock Construction Logic

The Create method locks only the Virtual Network:
- `locks.ByName(id.VirtualNetworkName, VirtualNetworkResourceName)`
- This constructs the lock string: `"azurerm_virtual_network.{vnet_name}"`

Update and Delete methods lock BOTH the Virtual Network AND the Subnet:
- `locks.ByName(id.VirtualNetworkName, VirtualNetworkResourceName)` → `"azurerm_virtual_network.{vnet_name}"`
- `locks.ByName(id.SubnetName, SubnetResourceName)` → `"azurerm_subnet.{subnet_name}"`

**Note:** For the azapi_resource replicator, we only need to implement the Create-phase lock (Virtual Network lock). The Update/Delete locks are handled by the root module's lifecycle management, not by this replicator module's output.

### Implementation

The Virtual Network name must be extracted from `var.virtual_network_id` (format: `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}`):

```hcl
locals {
  # Extract virtual network name from parent_id for locks
  # Index 8 corresponds to the virtualNetworkName segment in the resource ID path
  virtual_network_name = split("/", var.virtual_network_id)[8]
  
  locks = [
    "azurerm_virtual_network.${local.virtual_network_name}"
  ]
}
```

## Hidden Fields Analysis

### Root Properties Investigation
Examined all property assignments in the Create method. Every field in `SubnetPropertiesFormat` is populated from user input:
- `AddressPrefixes` - from `d.GetOk("address_prefixes")`
- `IPamPoolPrefixAllocations` - from `d.Get("ip_address_pool")`
- `PrivateEndpointNetworkPolicies` - from `d.Get("private_endpoint_network_policies")`
- `PrivateLinkServiceNetworkPolicies` - from `d.Get("private_link_service_network_policies_enabled")`
- `ServiceEndpointPolicies` - from `d.Get("service_endpoint_policy_ids")`
- `ServiceEndpoints` - from `d.Get("service_endpoints")`
- `SharingScope` - from `d.Get("sharing_scope")`
- `DefaultOutboundAccess` - from `d.Get("default_outbound_access_enabled")`
- `Delegations` - from `d.Get("delegation")`

**Conclusion:** No hidden fields exist. All fields are explicitly controlled by the user through the Terraform schema.

## Post-Creation Operations

**None identified.** The Create method follows a simple pattern:
1. Build the subnet object from user input
2. Call `CreateOrUpdateThenPoll` once
3. Wait for provisioning state (not a resource operation)
4. Return

No additional SDK operations (`CreateOrUpdate`, `Update`, etc.) are invoked after the primary create.

## Deferred Work Completion

Checked `following.md` - file does not exist, indicating no work was deferred to this task.

## Critical Review & Edge Case Analysis

### Null Semantics
- **Virtual Network Name Extraction:** The `split("/", var.virtual_network_id)[8]` will fail if the ID format is incorrect. However, this is acceptable because:
  - The `var.virtual_network_id` has validation that ensures it's a proper Azure resource ID
  - Invalid IDs would fail earlier in the validation phase
  - The ID format is enforced by Azure's resource ID structure

### Boundary Conditions
- **Empty Virtual Network ID:** Cannot occur due to `nullable = false` on the variable
- **Invalid ID Format:** Would be caught by validation before reaching this point
- **Lock String Construction:** The lock string format matches the provider's exact pattern

### Idempotency
- **Lock Extraction:** The lock string is deterministic - same input ID always produces same lock string
- **No State Dependencies:** The locks are computed from input variables only, not from existing state

### Safe References
- **Index Access:** The `split()[8]` is safe because Azure resource IDs have a fixed structure
- **Variable Reference:** `var.virtual_network_id` is guaranteed non-null due to variable constraints

## Checklist

- ✅ Property in correct local (locks added to local.locks)
- ✅ ForceNew wrapped: N/A (no ForceNew fields in this task)
- ✅ ALL logic EXACTLY replicated from provider (lock pattern matches provider exactly)
- ✅ Validations IMPLEMENTED in variables.tf: N/A (no new fields added)
- ✅ TODO comment added to original field in variables.tf: N/A (no sensitive fields)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work in following.md: N/A (no work deferred from this task)
- ✅ Deferred work from following.md: Checked (file doesn't exist)
- ✅ Critical review (null, edge, idempotent, safe refs) - completed above
- ✅ Edge Case Analysis in proof - completed above
- ✅ Proof created
- ✅ track.md ready to update to "Pending for check"
- ✅ Self-Review: Only implemented what Task #11 requires (locks), no other tasks' content added

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-20
**Task:** #11 - __check_root_hidden_fields__

### Validation Results

✅ **Task Type 2 Requirements:** All requirements satisfied - Create method queried, multi-phase pattern checked (single-phase confirmed), hidden fields investigated (none found), locks identified and implemented, proof created
✅ **Lock Detection:** Proper lock pattern identified from provider source code with correct Go evidence. Virtual Network lock extracted using correct Azure Resource ID index (split()[8])
✅ **Hidden Fields Analysis:** Thorough investigation shows all fields in SubnetPropertiesFormat are user-controlled via d.GetOk()/d.Get() - no hardcoded values
✅ **Post-Creation Operations:** Correctly identified as single-phase pattern with no additional SDK operations after primary CreateOrUpdateThenPoll
✅ **Lock Implementation:** Lock string format matches provider exactly: "azurerm_virtual_network.${vnet_name}"
✅ **Deferred Work Completion:** No deferred work for this task (following.md doesn't exist)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** Proper analysis of null semantics, boundary conditions, idempotency, and safe references

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The lock detection matches the provider's exact pattern from the Create method. The conclusion that no hidden fields exist is supported by thorough analysis of all property assignments showing they are all user-controlled. The lock extraction logic using index 8 is correct for Azure Resource ID structure.

**Status:** APPROVED ✅

---
