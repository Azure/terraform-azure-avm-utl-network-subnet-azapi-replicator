# Task #9: service_endpoints - Proof Document

## Summary

Implemented `service_endpoints` as an optional field that accepts a set of service endpoint strings (e.g., `Microsoft.Storage`, `Microsoft.KeyVault`). The provider expands these strings into objects with a `service` property for the Azure API, and flattens them back to strings when reading. This field can be updated without forcing resource replacement.

## Shadow Implementation

```hcl
# In migrate_main.tf
locals {
  body = {
    properties = merge(
      # ... other fields ...
      var.service_endpoints != null ? {  # <-
        serviceEndpoints = [for endpoint in var.service_endpoints : { service = endpoint }]  # <-
      } : {}  # <-
    )
  }
}
```

## Create Phase Verification

**Query Create Method:**
```go
func resourceSubnetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ... setup code ...

	properties := subnets.SubnetPropertiesFormat{}
	// ... other properties ...

	serviceEndpointsRaw := d.Get("service_endpoints").(*pluginsdk.Set).List()
	properties.ServiceEndpoints = expandSubnetServiceEndpoints(serviceEndpointsRaw)

	// ... more properties ...

	subnet := subnets.Subnet{
		Name:       pointer.To(id.SubnetName),
		Properties: &properties,
	}

	if err := client.CreateOrUpdateThenPoll(ctx, id, subnet); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}
	// ... completion logic ...
}
```

**Pattern Identified:** Single-phase operation - field is set in the primary `CreateOrUpdateThenPoll` call.

**Classification:** `service_endpoints` is processed in the **Create phase** (primary resource creation).

**Update Phase Verification:**
```go
func resourceSubnetUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ... setup code ...
	
	if d.HasChange("service_endpoints") {
		serviceEndpointsRaw := d.Get("service_endpoints").(*pluginsdk.Set).List()
		props.ServiceEndpoints = expandSubnetServiceEndpoints(serviceEndpointsRaw)
	}

	// ... update via CreateOrUpdateThenPoll ...
}
```

The field can be updated without forcing replacement - no `ForceNew: true` in schema.

## Assignment Path Verification

**Predicted Path:** `body.properties.serviceEndpoints`

**Go Code Evidence (Create):**
```go
// Step 1: Read from Terraform state
serviceEndpointsRaw := d.Get("service_endpoints").(*pluginsdk.Set).List()

// Step 2: Call expand function
properties.ServiceEndpoints = expandSubnetServiceEndpoints(serviceEndpointsRaw)

// Step 3: Assign properties to subnet
subnet := subnets.Subnet{
	Name:       pointer.To(id.SubnetName),
	Properties: &properties,  // <- ServiceEndpoints is inside Properties
}
```

**Verified Path:** `properties.serviceEndpoints` (Go) → `body.properties.serviceEndpoints` (AzAPI)

**Path Comparison:** ✅ Match - The predicted path matches the actual assignment path.

## Provider Schema

**Source:** `resourceSubnet()` function in azurerm provider

```go
"service_endpoints": {
	Type:     pluginsdk.TypeSet,
	Optional: true,
	Elem:     &pluginsdk.Schema{Type: pluginsdk.TypeString},
	Set:      pluginsdk.HashString,
},
```

**Schema Details:**
- **Type:** Set of strings
- **Required:** No (Optional)
- **ForceNew:** No (can be updated in-place)
- **Validations:** None
- **Default:** None
- **Computed:** No

## Azure API Schema

**Resource Type:** `Microsoft.Network/virtualNetworks/subnets`

**API Version:** `2024-07-01` (latest stable)

**Property Path:** `body.properties.serviceEndpoints`

**Type:** Array of objects with structure:
```
{
  "service": String,      // Required - the service endpoint name
  "locations": [String],  // Optional - list of locations
  "networkIdentifier": {  // Optional - network identifier
    "id": String
  }
}
```

**Description:** "An array of service endpoints."

**Provider Behavior:** The provider only sets the `service` field, leaving `locations` and `networkIdentifier` as optional/computed fields managed by Azure.

## Hidden Fields

None. The provider expand function only sets the `service` field:

```go
func expandSubnetServiceEndpoints(input []interface{}) *[]subnets.ServiceEndpointPropertiesFormat {
	endpoints := make([]subnets.ServiceEndpointPropertiesFormat, 0)

	for _, svcEndpointRaw := range input {
		if svc, ok := svcEndpointRaw.(string); ok {
			endpoint := subnets.ServiceEndpointPropertiesFormat{
				Service: &svc,  // <- Only sets service field
			}
			endpoints = append(endpoints, endpoint)
		}
	}

	return &endpoints
}
```

The `locations` and `networkIdentifier` fields are not set by the provider and are left to Azure's management.

## Mapping

**Terraform (snake_case):** `service_endpoints`

**Azure API (camelCase):** `serviceEndpoints`

**Conversion:** Direct camelCase conversion following standard naming conventions.

## Special Handling

### 1. Expand/Flatten Transformation

**Expand (Terraform → Azure):**
- Input: Set of strings (e.g., `["Microsoft.Storage", "Microsoft.KeyVault"]`)
- Output: Array of objects (e.g., `[{service: "Microsoft.Storage"}, {service: "Microsoft.KeyVault"}]`)

**Flatten (Azure → Terraform):**
```go
func flattenSubnetServiceEndpoints(serviceEndpoints *[]subnets.ServiceEndpointPropertiesFormat) []interface{} {
	endpoints := make([]interface{}, 0)

	if serviceEndpoints == nil {
		return endpoints
	}

	for _, endpoint := range *serviceEndpoints {
		if endpoint.Service != nil {
			endpoints = append(endpoints, *endpoint.Service)  // <- Extract only service field
		}
	}

	return endpoints
}
```

The flatten function extracts only the `service` field from the API response objects.

### 2. No ForceNew

The field does NOT have `ForceNew: true` in the schema and the Update method explicitly handles changes:

```go
if d.HasChange("service_endpoints") {
	serviceEndpointsRaw := d.Get("service_endpoints").(*pluginsdk.Set).List()
	props.ServiceEndpoints = expandSubnetServiceEndpoints(serviceEndpointsRaw)
}
```

**Implementation:** No entry in `replace_triggers_external_values`.

### 3. No Validations

The provider schema has no validation functions for this field. Users can specify any service endpoint string values.

### 4. Set Type Handling

The field is defined as a `Set` in Terraform, which means:
- No duplicates allowed
- Order is not significant
- Terraform automatically handles deduplication

**Implementation:** Converted to array for Azure API using `for` expression.

## Deferred Work Completion

Checked `following.md` - no work deferred to Task #9.

## Critical Review & Edge Case Analysis

### Null Semantics
- **`null` value:** Field is omitted from API request (not sent)
- **Empty set `[]`:** Would send empty array `[]` to API
- **Provider behavior:** Treats `null` as "no service endpoints configured"

### Boundary Conditions
- **Empty set:** If user sets `service_endpoints = []`, the implementation would create an empty merge object, effectively not sending the field
- **Single item:** Works correctly - creates array with one object
- **Multiple items:** Works correctly - creates array with multiple objects

### Idempotency
- ✅ **Order independent:** Using set type ensures order doesn't matter
- ✅ **Deterministic:** For same input set, always produces same array (within set ordering)
- ✅ **No state drift:** Flatten function extracts only `service` field, matching what expand sets

### Safe References
- ✅ **Null check:** `var.service_endpoints != null` checks before accessing
- ✅ **Safe iteration:** Using `for` over set is safe even if set is empty
- ✅ **No nested access risks:** Direct property assignment, no deep nesting

### Edge Case: API Returns Additional Fields

The Azure API may return `locations` and `networkIdentifier` in the response, but the provider's flatten function ignores these and only extracts the `service` field. This is correct behavior because:

1. The provider only manages the `service` field
2. `locations` and `networkIdentifier` are computed/managed by Azure
3. Ignoring them prevents state drift

**No issues identified.**

## Checklist

- ✅ Property in correct local (`body.properties`)
- ✅ All logic exactly replicated from provider (expand to objects with `service` field)
- ✅ Validations reviewed - none required (no validations in provider schema)
- ✅ Hidden fields checked - none (only `service` field is set)
- ✅ Deferred work checked - none for this task
- ✅ Critical review completed (null, edge, idempotent, safe refs)
- ✅ Edge Case Analysis included
- ✅ Proof created
- ✅ track.md will be updated to "Pending for check"
- ✅ Self-Review: Implementation matches exact provider behavior - strings expanded to objects with `service` property

## Implementation Verification

**Provider behavior replicated:**
1. ✅ Takes set of strings as input
2. ✅ Converts each string to an object with `service` property
3. ✅ Creates array of these objects for Azure API
4. ✅ Field is optional (conditional merge)
5. ✅ No ForceNew (updatable in-place)
6. ✅ No validations (matches provider schema)

**Exact replication confirmed:** The implementation precisely matches the provider's expand function logic.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent  
**Date:** 2026-01-20  
**Task:** #9 - service_endpoints

### Validation Results

✅ **ForceNew Logic:** No ForceNew (field can be updated in-place) - correctly no entry in `replace_triggers_external_values`  
✅ **Stable Keys:** Conditional merge used appropriately - key appears/disappears as a whole merge object (acceptable pattern)  
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase, primary operation)  
✅ **Type Conversion:** Correct conversion from `set(string)` to array of objects `[{service: string}]`  
✅ **Null Handling:** Correctly uses conditional merge - field omitted when null  
✅ **Validations:** None required (provider schema has no validations) - correctly none implemented  
✅ **Expand/Flatten Transformation:** EXACTLY replicated - strings → objects with `service` field only  
✅ **Deferred Work Completion:** No deferred work for this task (checked `following.md`)  
✅ **Deferred Work Recording:** No deferrals made by this task  
✅ **Edge Cases:** Comprehensive analysis in proof document - null semantics, empty set, idempotency, safe references all covered  
✅ **Hidden Fields:** Correctly documented that only `service` field is set (no hidden fields)  
✅ **Assignment Path:** Correctly traced through Go code - `properties.serviceEndpoints` verified  
✅ **Shared Path Merge:** No conflicts - `serviceEndpoints` appears only once in merge  
✅ **Method Priority:** Direct implementation (no priority choice needed)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The transformation logic from set of strings to array of objects with `service` property matches the provider's `expandSubnetServiceEndpoints` function precisely. No deviations, simplifications, or "safer alternatives" were found.

**Comparison Evidence:**
- **Provider:** Takes `[]interface{}` of strings → creates `[]ServiceEndpointPropertiesFormat` with only `Service` field set
- **Shadow Module:** Takes `set(string)` → creates array of objects `[{service: string}]` via `for` expression
- **Result:** Identical API payload structure

**Status:** APPROVED ✅

---
